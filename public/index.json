[{"content":" Disclaimer: this blog post is meant strictly for educational and ethical security research. Do not reverse engineer software without permission.\nüß† introduction reverse engineering python applications can be fascinating, especially when they‚Äôre bundled into .exe files using tools like pyinstaller. In this post, I\u0026rsquo;ll walk you through how I deconstructed a windows executable (app.exe), identified it as a pyinstaller package, and recovered the original app.py source code.\nüîç step 1: passive recon I started with no source just a single app.exe binary.\nchecking file properties first, I ran the classic:\n$ file app.exe # returns the type of file app.exe: PE32+ executable (GUI) x86-64, for MS Windows, 7 sections now we know that this is a windows executable file.\nwe could just use strings to confirm weather it is a pyinstaller package or not:\n$ strings app.exe | grep pyinstaller # should return strings matching pyinstaller _pyinstaller_pyz this confirms that it is a pyinstaller bundled python application.\nüîß step 2: extraction using an extractor these pyinstaller bundled .exe files are like a zip file which we could just extract using tools like pyinstxtractor.\n$ python3 pyinstxtractor.py app.exe [+] Processing app.exe [+] Pyinstaller version: 2.1+ [+] Python version: 3.10 [+] Length of package: 59743120 bytes [+] Found 1008 files in CArchive [+] Beginning extraction...please standby [+] Possible entry point: pyiboot01_bootstrap.pyc [+] Possible entry point: pyi_rth_inspect.pyc [+] Possible entry point: pyi_rth_pkgutil.pyc [+] Possible entry point: pyi_rth_multiprocessing.pyc [+] Possible entry point: pyi_rth__tkinter.pyc [+] Possible entry point: exe.pyc [!] Warning: This script is running in a different Python version than the one used to build the executable. [!] Please run this script in Python 3.10 to prevent extraction errors during unmarshalling [!] Skipping pyz extraction [+] Successfully extracted pyinstaller archive: app.exe You can now use a python decompiler on the pyc files within the extracted directory now we have a folder named app.exe_extracted in our working directory and will contain the entire python source bytecode which we could process further. Also this output contains metadata about python and pyinstaller versions which will come handy during decompilation.\nin the app.exe_extracted folder we have the following files(entire python bytecode):\nPIL _lzma.pyd cv2 pyi_rth_inspect.pyc select.pyd PYZ.pyz _multiprocessing.pyd app.pyc pyi_rth_multiprocessing.pyc struct.pyc PYZ.pyz_extracted _overlapped.pyd libcrypto-1_1.dll pyi_rth_pkgutil.pyc tcl8 VCRUNTIME140.dll _queue.pyd libffi-7.dll pyiboot01_bootstrap.pyc tcl86t.dll VCRUNTIME140_1.dll _socket.pyd libssl-1_1.dll pyimod01_archive.pyc tk86t.dll _asyncio.pyd _ssl.pyd numpy pyimod02_importers.pyc unicodedata.pyd _bz2.pyd _tcl_data numpy-2.2.6.dist-info pyimod03_ctypes.pyc win32 _ctypes.pyd _tk_data numpy.libs pyimod04_pywin32.pyc yaml _decimal.pyd _tkinter.pyd psutil python3.dll _elementtree.pyd base_library.zip pyexpat.pyd python310.dll _hashlib.pyd charset_normalizer pyi_rth__tkinter.pyc pywin32_system32 here we can see the entry/main python file named app.pyc which is the file we have to decompile.\ndecompilation we can use a tool like pycdc to decompile the python bytecode as it supports python version 3.10.\n$ pycdc ./app.exe_extracted/exe.pyc \u0026gt; app.py voila!, now we have the source code in the app.py file which is:\n# Source Generated with Decompyle++ # File: app.pyc (Python 3.10) import cv2 import threading import tkinter as tk from tkinter import messagebox from PIL import Image, ImageTk class App: def __init__(self, window): self.window = window self.window.title(\u0026#39;YOLOv8n Person Detection\u0026#39;) self.window.geometry(\u0026#39;800x640\u0026#39;) self.video_label = tk.Label(window) self.video_label.pack() button_frame = tk.Frame(window) button_frame.pack(10, **(\u0026#39;pady\u0026#39;,)) self.start_btn = tk.Button(button_frame, \u0026#39;Start Streaming\u0026#39;, (\u0026#39;Arial\u0026#39;, 12), self.start_thread, **(\u0026#39;text\u0026#39;, \u0026#39;font\u0026#39;, \u0026#39;command\u0026#39;)) self.start_btn.pack(tk.LEFT, 10, **(\u0026#39;side\u0026#39;, \u0026#39;padx\u0026#39;)) self.stop_btn = tk.Button(button_frame, \u0026#39;Stop Streaming\u0026#39;, (\u0026#39;Arial\u0026#39;, 12), self.stop_streaming, tk.DISABLED, **(\u0026#39;text\u0026#39;, \u0026#39;font\u0026#39;, \u0026#39;command\u0026#39;, \u0026#39;state\u0026#39;)) self.stop_btn.pack(tk.LEFT, 10, **(\u0026#39;side\u0026#39;, \u0026#39;padx\u0026#39;)) self.cap = None self.streaming = False def start_thread(self): if not self.streaming: self.streaming = True self.stop_btn.config(tk.NORMAL, **(\u0026#39;state\u0026#39;,)) self.start_btn.config(tk.DISABLED, **(\u0026#39;state\u0026#39;,)) threading.Thread(self.stream, **(\u0026#39;target\u0026#39;,)).start() return None def stream(self): self.cap = cv2.VideoCapture(0) if not self.cap.isOpened(): messagebox.showerror(\u0026#39;Error\u0026#39;, \u0026#39;‚ùå Cannot open video stream.\u0026#39;) self.reset_buttons() return None if None.streaming: (ret, frame) = self.cap.read() if not ret: pass else: frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB) img = Image.fromarray(frame_rgb) imgtk = ImageTk.PhotoImage(img, **(\u0026#39;image\u0026#39;,)) self.video_label.imgtk = imgtk self.video_label.config(imgtk, **(\u0026#39;image\u0026#39;,)) if not self.streaming: self.cap.release() self.reset_buttons() return None def stop_streaming(self): self.streaming = False if self.cap: self.cap.release() self.window.after(100, self.window.destroy) def reset_buttons(self): self.start_btn.config(tk.NORMAL, **(\u0026#39;state\u0026#39;,)) self.stop_btn.config(tk.DISABLED, **(\u0026#39;state\u0026#39;,)) def on_close(self): self.streaming = False if self.cap: self.cap.release() self.window.destroy() root = tk.Tk() app = App(root) root.protocol(\u0026#39;WM_DELETE_WINDOW\u0026#39;, app.on_close) root.mainloop() this looks like an application that uses your webcam to display a real-time video feed with OpenCV.\nüì¶ lessons to note pyInstaller doesn\u0026rsquo;t truly compile it\u0026rsquo;s packages. security through obscurity isn‚Äôt real security. tools like pyinstxtractor, pycdc are powerful allies for binary introspection. always check the Python version before decompiling. üìå final thoughts reverse engineering can be easy with the help of AI tools like chatgpt and likely tooling but still requires a methodical approach.\nalways make sure you‚Äôre authorized to reverse engineer the application you‚Äôre looking into. This stuff gets legally gray real fast.\n","permalink":"http://localhost:1313/posts/reverse-engineer-python-gui-application/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eDisclaimer: this blog post is meant strictly for educational and ethical security research. Do not reverse engineer software without permission.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"-introduction\"\u003eüß† introduction\u003c/h2\u003e\n\u003cp\u003ereverse engineering python applications can be fascinating, especially when they‚Äôre bundled into \u003ccode\u003e.exe\u003c/code\u003e files using tools like pyinstaller. In this post, I\u0026rsquo;ll walk you through how I deconstructed a windows executable (\u003ccode\u003eapp.exe\u003c/code\u003e), identified it as a pyinstaller package, and recovered the original \u003ccode\u003eapp.py\u003c/code\u003e source code.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-step-1-passive-recon\"\u003eüîç step 1: passive recon\u003c/h2\u003e\n\u003cp\u003eI started with no source just a single \u003ccode\u003eapp.exe\u003c/code\u003e binary.\u003c/p\u003e","title":"reverse engineering a python application built using pyinstaller"},{"content":"","permalink":"http://localhost:1313/projects/","summary":"","title":""},{"content":"I am sahl and I make, break and hack stuff.\nget my resume here\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI am \u003cstrong\u003esahl\u003c/strong\u003e and I make, break and hack stuff.\u003c/p\u003e\n\u003cp\u003eget my resume \u003ca href=\"/files/resume.pdf\"\u003ehere\u003c/a\u003e\u003c/p\u003e","title":"welcome to my blog!"},{"content":" Disclaimer: this blog post is meant strictly for educational and ethical security research. Do not reverse engineer software without permission.\nüß† introduction reverse engineering python applications can be fascinating, especially when they‚Äôre bundled into .exe files using tools like pyinstaller. In this post, I\u0026rsquo;ll walk you through how I deconstructed a windows executable (app.exe), identified it as a pyinstaller package, and recovered the original app.py source code.\nüîç step 1: passive recon I started with no source just a single app.exe binary.\nchecking file properties first, I ran the classic:\n$ file app.exe # returns the type of file app.exe: PE32+ executable (GUI) x86-64, for MS Windows, 7 sections now we know that this is a windows executable file.\nwe could just use strings to confirm weather it is a pyinstaller package or not:\n$ strings app.exe | grep pyinstaller # should return strings matching pyinstaller _pyinstaller_pyz this confirms that it is a pyinstaller bundled python application.\nüîß step 2: extraction using an extractor these pyinstaller bundled .exe files are like a zip file which we could just extract using tools like pyinstxtractor.\n$ python3 pyinstxtractor.py app.exe [+] Processing app.exe [+] Pyinstaller version: 2.1+ [+] Python version: 3.10 [+] Length of package: 59743120 bytes [+] Found 1008 files in CArchive [+] Beginning extraction...please standby [+] Possible entry point: pyiboot01_bootstrap.pyc [+] Possible entry point: pyi_rth_inspect.pyc [+] Possible entry point: pyi_rth_pkgutil.pyc [+] Possible entry point: pyi_rth_multiprocessing.pyc [+] Possible entry point: pyi_rth__tkinter.pyc [+] Possible entry point: exe.pyc [!] Warning: This script is running in a different Python version than the one used to build the executable. [!] Please run this script in Python 3.10 to prevent extraction errors during unmarshalling [!] Skipping pyz extraction [+] Successfully extracted pyinstaller archive: app.exe You can now use a python decompiler on the pyc files within the extracted directory now we have a folder named app.exe_extracted in our working directory and will contain the entire python source bytecode which we could process further. Also this output contains metadata about python and pyinstaller versions which will come handy during decompilation.\nin the app.exe_extracted folder we have the following files(entire python bytecode):\nPIL _lzma.pyd cv2 pyi_rth_inspect.pyc select.pyd PYZ.pyz _multiprocessing.pyd app.pyc pyi_rth_multiprocessing.pyc struct.pyc PYZ.pyz_extracted _overlapped.pyd libcrypto-1_1.dll pyi_rth_pkgutil.pyc tcl8 VCRUNTIME140.dll _queue.pyd libffi-7.dll pyiboot01_bootstrap.pyc tcl86t.dll VCRUNTIME140_1.dll _socket.pyd libssl-1_1.dll pyimod01_archive.pyc tk86t.dll _asyncio.pyd _ssl.pyd numpy pyimod02_importers.pyc unicodedata.pyd _bz2.pyd _tcl_data numpy-2.2.6.dist-info pyimod03_ctypes.pyc win32 _ctypes.pyd _tk_data numpy.libs pyimod04_pywin32.pyc yaml _decimal.pyd _tkinter.pyd psutil python3.dll _elementtree.pyd base_library.zip pyexpat.pyd python310.dll _hashlib.pyd charset_normalizer pyi_rth__tkinter.pyc pywin32_system32 here we can see the entry/main python file named app.pyc which is the file we have to decompile.\ndecompilation we can use a tool like pycdc to decompile the python bytecode as it supports python version 3.10.\n$ pycdc ./app.exe_extracted/exe.pyc \u0026gt; app.py voila!, now we have the source code in the app.py file which is:\n# Source Generated with Decompyle++ # File: app.pyc (Python 3.10) import cv2 import threading import tkinter as tk from tkinter import messagebox from PIL import Image, ImageTk class App: def __init__(self, window): self.window = window self.window.title(\u0026#39;YOLOv8n Person Detection\u0026#39;) self.window.geometry(\u0026#39;800x640\u0026#39;) self.video_label = tk.Label(window) self.video_label.pack() button_frame = tk.Frame(window) button_frame.pack(10, **(\u0026#39;pady\u0026#39;,)) self.start_btn = tk.Button(button_frame, \u0026#39;Start Streaming\u0026#39;, (\u0026#39;Arial\u0026#39;, 12), self.start_thread, **(\u0026#39;text\u0026#39;, \u0026#39;font\u0026#39;, \u0026#39;command\u0026#39;)) self.start_btn.pack(tk.LEFT, 10, **(\u0026#39;side\u0026#39;, \u0026#39;padx\u0026#39;)) self.stop_btn = tk.Button(button_frame, \u0026#39;Stop Streaming\u0026#39;, (\u0026#39;Arial\u0026#39;, 12), self.stop_streaming, tk.DISABLED, **(\u0026#39;text\u0026#39;, \u0026#39;font\u0026#39;, \u0026#39;command\u0026#39;, \u0026#39;state\u0026#39;)) self.stop_btn.pack(tk.LEFT, 10, **(\u0026#39;side\u0026#39;, \u0026#39;padx\u0026#39;)) self.cap = None self.streaming = False def start_thread(self): if not self.streaming: self.streaming = True self.stop_btn.config(tk.NORMAL, **(\u0026#39;state\u0026#39;,)) self.start_btn.config(tk.DISABLED, **(\u0026#39;state\u0026#39;,)) threading.Thread(self.stream, **(\u0026#39;target\u0026#39;,)).start() return None def stream(self): self.cap = cv2.VideoCapture(0) if not self.cap.isOpened(): messagebox.showerror(\u0026#39;Error\u0026#39;, \u0026#39;‚ùå Cannot open video stream.\u0026#39;) self.reset_buttons() return None if None.streaming: (ret, frame) = self.cap.read() if not ret: pass else: frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB) img = Image.fromarray(frame_rgb) imgtk = ImageTk.PhotoImage(img, **(\u0026#39;image\u0026#39;,)) self.video_label.imgtk = imgtk self.video_label.config(imgtk, **(\u0026#39;image\u0026#39;,)) if not self.streaming: self.cap.release() self.reset_buttons() return None def stop_streaming(self): self.streaming = False if self.cap: self.cap.release() self.window.after(100, self.window.destroy) def reset_buttons(self): self.start_btn.config(tk.NORMAL, **(\u0026#39;state\u0026#39;,)) self.stop_btn.config(tk.DISABLED, **(\u0026#39;state\u0026#39;,)) def on_close(self): self.streaming = False if self.cap: self.cap.release() self.window.destroy() root = tk.Tk() app = App(root) root.protocol(\u0026#39;WM_DELETE_WINDOW\u0026#39;, app.on_close) root.mainloop() this looks like an application that uses your webcam to display a real-time video feed with OpenCV.\nüì¶ lessons to note pyInstaller doesn\u0026rsquo;t truly compile it\u0026rsquo;s packages. security through obscurity isn‚Äôt real security. tools like pyinstxtractor, pycdc are powerful allies for binary introspection. always check the Python version before decompiling. üìå final thoughts reverse engineering can be easy with the help of AI tools like chatgpt and likely tooling but still requires a methodical approach.\nalways make sure you‚Äôre authorized to reverse engineer the application you‚Äôre looking into. This stuff gets legally gray real fast.\n","permalink":"http://localhost:1313/posts/reverse-engineer-python-gui-application/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eDisclaimer: this blog post is meant strictly for educational and ethical security research. Do not reverse engineer software without permission.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"-introduction\"\u003eüß† introduction\u003c/h2\u003e\n\u003cp\u003ereverse engineering python applications can be fascinating, especially when they‚Äôre bundled into \u003ccode\u003e.exe\u003c/code\u003e files using tools like pyinstaller. In this post, I\u0026rsquo;ll walk you through how I deconstructed a windows executable (\u003ccode\u003eapp.exe\u003c/code\u003e), identified it as a pyinstaller package, and recovered the original \u003ccode\u003eapp.py\u003c/code\u003e source code.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-step-1-passive-recon\"\u003eüîç step 1: passive recon\u003c/h2\u003e\n\u003cp\u003eI started with no source just a single \u003ccode\u003eapp.exe\u003c/code\u003e binary.\u003c/p\u003e","title":"reverse engineering a python application built using pyinstaller"},{"content":"","permalink":"http://localhost:1313/projects/","summary":"","title":""},{"content":"I am sahl and I make, break and hack stuff.\nget my resume here\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI am \u003cstrong\u003esahl\u003c/strong\u003e and I make, break and hack stuff.\u003c/p\u003e\n\u003cp\u003eget my resume \u003ca href=\"/files/resume.pdf\"\u003ehere\u003c/a\u003e\u003c/p\u003e","title":"welcome to my blog!"},{"content":" Disclaimer: this blog post is meant strictly for educational and ethical security research. Do not reverse engineer software without permission.\nüß† introduction reverse engineering python applications can be fascinating, especially when they‚Äôre bundled into .exe files using tools like pyinstaller. In this post, I\u0026rsquo;ll walk you through how I deconstructed a windows executable (app.exe), identified it as a pyinstaller package, and recovered the original app.py source code.\nüîç step 1: passive recon I started with no source just a single app.exe binary.\nchecking file properties first, I ran the classic:\n$ file app.exe # returns the type of file app.exe: PE32+ executable (GUI) x86-64, for MS Windows, 7 sections now we know that this is a windows executable file.\nwe could just use strings to confirm weather it is a pyinstaller package or not:\n$ strings app.exe | grep pyinstaller # should return strings matching pyinstaller _pyinstaller_pyz this confirms that it is a pyinstaller bundled python application.\nüîß step 2: extraction using an extractor these pyinstaller bundled .exe files are like a zip file which we could just extract using tools like pyinstxtractor.\n$ python3 pyinstxtractor.py app.exe [+] Processing app.exe [+] Pyinstaller version: 2.1+ [+] Python version: 3.10 [+] Length of package: 59743120 bytes [+] Found 1008 files in CArchive [+] Beginning extraction...please standby [+] Possible entry point: pyiboot01_bootstrap.pyc [+] Possible entry point: pyi_rth_inspect.pyc [+] Possible entry point: pyi_rth_pkgutil.pyc [+] Possible entry point: pyi_rth_multiprocessing.pyc [+] Possible entry point: pyi_rth__tkinter.pyc [+] Possible entry point: exe.pyc [!] Warning: This script is running in a different Python version than the one used to build the executable. [!] Please run this script in Python 3.10 to prevent extraction errors during unmarshalling [!] Skipping pyz extraction [+] Successfully extracted pyinstaller archive: app.exe You can now use a python decompiler on the pyc files within the extracted directory now we have a folder named app.exe_extracted in our working directory and will contain the entire python source bytecode which we could process further. Also this output contains metadata about python and pyinstaller versions which will come handy during decompilation.\nin the app.exe_extracted folder we have the following files(entire python bytecode):\nPIL _lzma.pyd cv2 pyi_rth_inspect.pyc select.pyd PYZ.pyz _multiprocessing.pyd app.pyc pyi_rth_multiprocessing.pyc struct.pyc PYZ.pyz_extracted _overlapped.pyd libcrypto-1_1.dll pyi_rth_pkgutil.pyc tcl8 VCRUNTIME140.dll _queue.pyd libffi-7.dll pyiboot01_bootstrap.pyc tcl86t.dll VCRUNTIME140_1.dll _socket.pyd libssl-1_1.dll pyimod01_archive.pyc tk86t.dll _asyncio.pyd _ssl.pyd numpy pyimod02_importers.pyc unicodedata.pyd _bz2.pyd _tcl_data numpy-2.2.6.dist-info pyimod03_ctypes.pyc win32 _ctypes.pyd _tk_data numpy.libs pyimod04_pywin32.pyc yaml _decimal.pyd _tkinter.pyd psutil python3.dll _elementtree.pyd base_library.zip pyexpat.pyd python310.dll _hashlib.pyd charset_normalizer pyi_rth__tkinter.pyc pywin32_system32 here we can see the entry/main python file named app.pyc which is the file we have to decompile.\ndecompilation we can use a tool like pycdc to decompile the python bytecode as it supports python version 3.10.\n$ pycdc ./app.exe_extracted/exe.pyc \u0026gt; app.py voila!, now we have the source code in the app.py file which is:\n# Source Generated with Decompyle++ # File: app.pyc (Python 3.10) import cv2 import threading import tkinter as tk from tkinter import messagebox from PIL import Image, ImageTk class App: def __init__(self, window): self.window = window self.window.title(\u0026#39;YOLOv8n Person Detection\u0026#39;) self.window.geometry(\u0026#39;800x640\u0026#39;) self.video_label = tk.Label(window) self.video_label.pack() button_frame = tk.Frame(window) button_frame.pack(10, **(\u0026#39;pady\u0026#39;,)) self.start_btn = tk.Button(button_frame, \u0026#39;Start Streaming\u0026#39;, (\u0026#39;Arial\u0026#39;, 12), self.start_thread, **(\u0026#39;text\u0026#39;, \u0026#39;font\u0026#39;, \u0026#39;command\u0026#39;)) self.start_btn.pack(tk.LEFT, 10, **(\u0026#39;side\u0026#39;, \u0026#39;padx\u0026#39;)) self.stop_btn = tk.Button(button_frame, \u0026#39;Stop Streaming\u0026#39;, (\u0026#39;Arial\u0026#39;, 12), self.stop_streaming, tk.DISABLED, **(\u0026#39;text\u0026#39;, \u0026#39;font\u0026#39;, \u0026#39;command\u0026#39;, \u0026#39;state\u0026#39;)) self.stop_btn.pack(tk.LEFT, 10, **(\u0026#39;side\u0026#39;, \u0026#39;padx\u0026#39;)) self.cap = None self.streaming = False def start_thread(self): if not self.streaming: self.streaming = True self.stop_btn.config(tk.NORMAL, **(\u0026#39;state\u0026#39;,)) self.start_btn.config(tk.DISABLED, **(\u0026#39;state\u0026#39;,)) threading.Thread(self.stream, **(\u0026#39;target\u0026#39;,)).start() return None def stream(self): self.cap = cv2.VideoCapture(0) if not self.cap.isOpened(): messagebox.showerror(\u0026#39;Error\u0026#39;, \u0026#39;‚ùå Cannot open video stream.\u0026#39;) self.reset_buttons() return None if None.streaming: (ret, frame) = self.cap.read() if not ret: pass else: frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB) img = Image.fromarray(frame_rgb) imgtk = ImageTk.PhotoImage(img, **(\u0026#39;image\u0026#39;,)) self.video_label.imgtk = imgtk self.video_label.config(imgtk, **(\u0026#39;image\u0026#39;,)) if not self.streaming: self.cap.release() self.reset_buttons() return None def stop_streaming(self): self.streaming = False if self.cap: self.cap.release() self.window.after(100, self.window.destroy) def reset_buttons(self): self.start_btn.config(tk.NORMAL, **(\u0026#39;state\u0026#39;,)) self.stop_btn.config(tk.DISABLED, **(\u0026#39;state\u0026#39;,)) def on_close(self): self.streaming = False if self.cap: self.cap.release() self.window.destroy() root = tk.Tk() app = App(root) root.protocol(\u0026#39;WM_DELETE_WINDOW\u0026#39;, app.on_close) root.mainloop() this looks like an application that uses your webcam to display a real-time video feed with OpenCV.\nüì¶ lessons to note pyInstaller doesn\u0026rsquo;t truly compile it\u0026rsquo;s packages. security through obscurity isn‚Äôt real security. tools like pyinstxtractor, pycdc are powerful allies for binary introspection. always check the Python version before decompiling. üìå final thoughts reverse engineering can be easy with the help of AI tools like chatgpt and likely tooling but still requires a methodical approach.\nalways make sure you‚Äôre authorized to reverse engineer the application you‚Äôre looking into. This stuff gets legally gray real fast.\n","permalink":"http://localhost:1313/posts/reverse-engineer-python-gui-application/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eDisclaimer: this blog post is meant strictly for educational and ethical security research. Do not reverse engineer software without permission.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"-introduction\"\u003eüß† introduction\u003c/h2\u003e\n\u003cp\u003ereverse engineering python applications can be fascinating, especially when they‚Äôre bundled into \u003ccode\u003e.exe\u003c/code\u003e files using tools like pyinstaller. In this post, I\u0026rsquo;ll walk you through how I deconstructed a windows executable (\u003ccode\u003eapp.exe\u003c/code\u003e), identified it as a pyinstaller package, and recovered the original \u003ccode\u003eapp.py\u003c/code\u003e source code.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-step-1-passive-recon\"\u003eüîç step 1: passive recon\u003c/h2\u003e\n\u003cp\u003eI started with no source just a single \u003ccode\u003eapp.exe\u003c/code\u003e binary.\u003c/p\u003e","title":"reverse engineering a python application built using pyinstaller"},{"content":"","permalink":"http://localhost:1313/projects/","summary":"","title":""},{"content":"I am sahl and I make, break and hack stuff.\nget my resume here\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI am \u003cstrong\u003esahl\u003c/strong\u003e and I make, break and hack stuff.\u003c/p\u003e\n\u003cp\u003eget my resume \u003ca href=\"/files/resume.pdf\"\u003ehere\u003c/a\u003e\u003c/p\u003e","title":"welcome to my blog!"},{"content":" Disclaimer: this blog post is meant strictly for educational and ethical security research. Do not reverse engineer software without permission.\nüß† introduction reverse engineering python applications can be fascinating, especially when they‚Äôre bundled into .exe files using tools like pyinstaller. In this post, I\u0026rsquo;ll walk you through how I deconstructed a windows executable (app.exe), identified it as a pyinstaller package, and recovered the original app.py source code.\nüîç step 1: passive recon I started with no source just a single app.exe binary.\nchecking file properties first, I ran the classic:\n$ file app.exe # returns the type of file app.exe: PE32+ executable (GUI) x86-64, for MS Windows, 7 sections now we know that this is a windows executable file.\nwe could just use strings to confirm weather it is a pyinstaller package or not:\n$ strings app.exe | grep pyinstaller # should return strings matching pyinstaller _pyinstaller_pyz this confirms that it is a pyinstaller bundled python application.\nüîß step 2: extraction using an extractor these pyinstaller bundled .exe files are like a zip file which we could just extract using tools like pyinstxtractor.\n$ python3 pyinstxtractor.py app.exe [+] Processing app.exe [+] Pyinstaller version: 2.1+ [+] Python version: 3.10 [+] Length of package: 59743120 bytes [+] Found 1008 files in CArchive [+] Beginning extraction...please standby [+] Possible entry point: pyiboot01_bootstrap.pyc [+] Possible entry point: pyi_rth_inspect.pyc [+] Possible entry point: pyi_rth_pkgutil.pyc [+] Possible entry point: pyi_rth_multiprocessing.pyc [+] Possible entry point: pyi_rth__tkinter.pyc [+] Possible entry point: exe.pyc [!] Warning: This script is running in a different Python version than the one used to build the executable. [!] Please run this script in Python 3.10 to prevent extraction errors during unmarshalling [!] Skipping pyz extraction [+] Successfully extracted pyinstaller archive: app.exe You can now use a python decompiler on the pyc files within the extracted directory now we have a folder named app.exe_extracted in our working directory and will contain the entire python source bytecode which we could process further. Also this output contains metadata about python and pyinstaller versions which will come handy during decompilation.\nin the app.exe_extracted folder we have the following files(entire python bytecode):\nPIL _lzma.pyd cv2 pyi_rth_inspect.pyc select.pyd PYZ.pyz _multiprocessing.pyd app.pyc pyi_rth_multiprocessing.pyc struct.pyc PYZ.pyz_extracted _overlapped.pyd libcrypto-1_1.dll pyi_rth_pkgutil.pyc tcl8 VCRUNTIME140.dll _queue.pyd libffi-7.dll pyiboot01_bootstrap.pyc tcl86t.dll VCRUNTIME140_1.dll _socket.pyd libssl-1_1.dll pyimod01_archive.pyc tk86t.dll _asyncio.pyd _ssl.pyd numpy pyimod02_importers.pyc unicodedata.pyd _bz2.pyd _tcl_data numpy-2.2.6.dist-info pyimod03_ctypes.pyc win32 _ctypes.pyd _tk_data numpy.libs pyimod04_pywin32.pyc yaml _decimal.pyd _tkinter.pyd psutil python3.dll _elementtree.pyd base_library.zip pyexpat.pyd python310.dll _hashlib.pyd charset_normalizer pyi_rth__tkinter.pyc pywin32_system32 here we can see the entry/main python file named app.pyc which is the file we have to decompile.\ndecompilation we can use a tool like pycdc to decompile the python bytecode as it supports python version 3.10.\n$ pycdc ./app.exe_extracted/exe.pyc \u0026gt; app.py voila!, now we have the source code in the app.py file which is:\n# Source Generated with Decompyle++ # File: app.pyc (Python 3.10) import cv2 import threading import tkinter as tk from tkinter import messagebox from PIL import Image, ImageTk class App: def __init__(self, window): self.window = window self.window.title(\u0026#39;YOLOv8n Person Detection\u0026#39;) self.window.geometry(\u0026#39;800x640\u0026#39;) self.video_label = tk.Label(window) self.video_label.pack() button_frame = tk.Frame(window) button_frame.pack(10, **(\u0026#39;pady\u0026#39;,)) self.start_btn = tk.Button(button_frame, \u0026#39;Start Streaming\u0026#39;, (\u0026#39;Arial\u0026#39;, 12), self.start_thread, **(\u0026#39;text\u0026#39;, \u0026#39;font\u0026#39;, \u0026#39;command\u0026#39;)) self.start_btn.pack(tk.LEFT, 10, **(\u0026#39;side\u0026#39;, \u0026#39;padx\u0026#39;)) self.stop_btn = tk.Button(button_frame, \u0026#39;Stop Streaming\u0026#39;, (\u0026#39;Arial\u0026#39;, 12), self.stop_streaming, tk.DISABLED, **(\u0026#39;text\u0026#39;, \u0026#39;font\u0026#39;, \u0026#39;command\u0026#39;, \u0026#39;state\u0026#39;)) self.stop_btn.pack(tk.LEFT, 10, **(\u0026#39;side\u0026#39;, \u0026#39;padx\u0026#39;)) self.cap = None self.streaming = False def start_thread(self): if not self.streaming: self.streaming = True self.stop_btn.config(tk.NORMAL, **(\u0026#39;state\u0026#39;,)) self.start_btn.config(tk.DISABLED, **(\u0026#39;state\u0026#39;,)) threading.Thread(self.stream, **(\u0026#39;target\u0026#39;,)).start() return None def stream(self): self.cap = cv2.VideoCapture(0) if not self.cap.isOpened(): messagebox.showerror(\u0026#39;Error\u0026#39;, \u0026#39;‚ùå Cannot open video stream.\u0026#39;) self.reset_buttons() return None if None.streaming: (ret, frame) = self.cap.read() if not ret: pass else: frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB) img = Image.fromarray(frame_rgb) imgtk = ImageTk.PhotoImage(img, **(\u0026#39;image\u0026#39;,)) self.video_label.imgtk = imgtk self.video_label.config(imgtk, **(\u0026#39;image\u0026#39;,)) if not self.streaming: self.cap.release() self.reset_buttons() return None def stop_streaming(self): self.streaming = False if self.cap: self.cap.release() self.window.after(100, self.window.destroy) def reset_buttons(self): self.start_btn.config(tk.NORMAL, **(\u0026#39;state\u0026#39;,)) self.stop_btn.config(tk.DISABLED, **(\u0026#39;state\u0026#39;,)) def on_close(self): self.streaming = False if self.cap: self.cap.release() self.window.destroy() root = tk.Tk() app = App(root) root.protocol(\u0026#39;WM_DELETE_WINDOW\u0026#39;, app.on_close) root.mainloop() this looks like an application that uses your webcam to display a real-time video feed with OpenCV.\nüì¶ lessons to note pyInstaller doesn\u0026rsquo;t truly compile it\u0026rsquo;s packages. security through obscurity isn‚Äôt real security. tools like pyinstxtractor, pycdc are powerful allies for binary introspection. always check the Python version before decompiling. üìå final thoughts reverse engineering can be easy with the help of AI tools like chatgpt and likely tooling but still requires a methodical approach.\nalways make sure you‚Äôre authorized to reverse engineer the application you‚Äôre looking into. This stuff gets legally gray real fast.\n","permalink":"http://localhost:1313/posts/reverse-engineer-python-gui-application/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eDisclaimer: this blog post is meant strictly for educational and ethical security research. Do not reverse engineer software without permission.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"-introduction\"\u003eüß† introduction\u003c/h2\u003e\n\u003cp\u003ereverse engineering python applications can be fascinating, especially when they‚Äôre bundled into \u003ccode\u003e.exe\u003c/code\u003e files using tools like pyinstaller. In this post, I\u0026rsquo;ll walk you through how I deconstructed a windows executable (\u003ccode\u003eapp.exe\u003c/code\u003e), identified it as a pyinstaller package, and recovered the original \u003ccode\u003eapp.py\u003c/code\u003e source code.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-step-1-passive-recon\"\u003eüîç step 1: passive recon\u003c/h2\u003e\n\u003cp\u003eI started with no source just a single \u003ccode\u003eapp.exe\u003c/code\u003e binary.\u003c/p\u003e","title":"reverse engineering a python application built using pyinstaller"},{"content":"","permalink":"http://localhost:1313/projects/","summary":"","title":""},{"content":"I am sahl and I make, break and hack stuff.\nget my resume here\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI am \u003cstrong\u003esahl\u003c/strong\u003e and I make, break and hack stuff.\u003c/p\u003e\n\u003cp\u003eget my resume \u003ca href=\"/files/resume.pdf\"\u003ehere\u003c/a\u003e\u003c/p\u003e","title":"welcome to my blog!"},{"content":" Disclaimer: this blog post is meant strictly for educational and ethical security research. Do not reverse engineer software without permission.\nüß† introduction reverse engineering python applications can be fascinating, especially when they‚Äôre bundled into .exe files using tools like pyinstaller. In this post, I\u0026rsquo;ll walk you through how I deconstructed a windows executable (app.exe), identified it as a pyinstaller package, and recovered the original app.py source code.\nüîç step 1: passive recon I started with no source just a single app.exe binary.\nchecking file properties first, I ran the classic:\n$ file app.exe # returns the type of file app.exe: PE32+ executable (GUI) x86-64, for MS Windows, 7 sections now we know that this is a windows executable file.\nwe could just use strings to confirm weather it is a pyinstaller package or not:\n$ strings app.exe | grep pyinstaller # should return strings matching pyinstaller _pyinstaller_pyz this confirms that it is a pyinstaller bundled python application.\nüîß step 2: extraction using an extractor these pyinstaller bundled .exe files are like a zip file which we could just extract using tools like pyinstxtractor.\n$ python3 pyinstxtractor.py app.exe [+] Processing app.exe [+] Pyinstaller version: 2.1+ [+] Python version: 3.10 [+] Length of package: 59743120 bytes [+] Found 1008 files in CArchive [+] Beginning extraction...please standby [+] Possible entry point: pyiboot01_bootstrap.pyc [+] Possible entry point: pyi_rth_inspect.pyc [+] Possible entry point: pyi_rth_pkgutil.pyc [+] Possible entry point: pyi_rth_multiprocessing.pyc [+] Possible entry point: pyi_rth__tkinter.pyc [+] Possible entry point: exe.pyc [!] Warning: This script is running in a different Python version than the one used to build the executable. [!] Please run this script in Python 3.10 to prevent extraction errors during unmarshalling [!] Skipping pyz extraction [+] Successfully extracted pyinstaller archive: app.exe You can now use a python decompiler on the pyc files within the extracted directory now we have a folder named app.exe_extracted in our working directory and will contain the entire python source bytecode which we could process further. Also this output contains metadata about python and pyinstaller versions which will come handy during decompilation.\nin the app.exe_extracted folder we have the following files(entire python bytecode):\nPIL _lzma.pyd cv2 pyi_rth_inspect.pyc select.pyd PYZ.pyz _multiprocessing.pyd app.pyc pyi_rth_multiprocessing.pyc struct.pyc PYZ.pyz_extracted _overlapped.pyd libcrypto-1_1.dll pyi_rth_pkgutil.pyc tcl8 VCRUNTIME140.dll _queue.pyd libffi-7.dll pyiboot01_bootstrap.pyc tcl86t.dll VCRUNTIME140_1.dll _socket.pyd libssl-1_1.dll pyimod01_archive.pyc tk86t.dll _asyncio.pyd _ssl.pyd numpy pyimod02_importers.pyc unicodedata.pyd _bz2.pyd _tcl_data numpy-2.2.6.dist-info pyimod03_ctypes.pyc win32 _ctypes.pyd _tk_data numpy.libs pyimod04_pywin32.pyc yaml _decimal.pyd _tkinter.pyd psutil python3.dll _elementtree.pyd base_library.zip pyexpat.pyd python310.dll _hashlib.pyd charset_normalizer pyi_rth__tkinter.pyc pywin32_system32 here we can see the entry/main python file named app.pyc which is the file we have to decompile.\ndecompilation we can use a tool like pycdc to decompile the python bytecode as it supports python version 3.10.\n$ pycdc ./app.exe_extracted/exe.pyc \u0026gt; app.py voila!, now we have the source code in the app.py file which is:\n# Source Generated with Decompyle++ # File: app.pyc (Python 3.10) import cv2 import threading import tkinter as tk from tkinter import messagebox from PIL import Image, ImageTk class App: def __init__(self, window): self.window = window self.window.title(\u0026#39;YOLOv8n Person Detection\u0026#39;) self.window.geometry(\u0026#39;800x640\u0026#39;) self.video_label = tk.Label(window) self.video_label.pack() button_frame = tk.Frame(window) button_frame.pack(10, **(\u0026#39;pady\u0026#39;,)) self.start_btn = tk.Button(button_frame, \u0026#39;Start Streaming\u0026#39;, (\u0026#39;Arial\u0026#39;, 12), self.start_thread, **(\u0026#39;text\u0026#39;, \u0026#39;font\u0026#39;, \u0026#39;command\u0026#39;)) self.start_btn.pack(tk.LEFT, 10, **(\u0026#39;side\u0026#39;, \u0026#39;padx\u0026#39;)) self.stop_btn = tk.Button(button_frame, \u0026#39;Stop Streaming\u0026#39;, (\u0026#39;Arial\u0026#39;, 12), self.stop_streaming, tk.DISABLED, **(\u0026#39;text\u0026#39;, \u0026#39;font\u0026#39;, \u0026#39;command\u0026#39;, \u0026#39;state\u0026#39;)) self.stop_btn.pack(tk.LEFT, 10, **(\u0026#39;side\u0026#39;, \u0026#39;padx\u0026#39;)) self.cap = None self.streaming = False def start_thread(self): if not self.streaming: self.streaming = True self.stop_btn.config(tk.NORMAL, **(\u0026#39;state\u0026#39;,)) self.start_btn.config(tk.DISABLED, **(\u0026#39;state\u0026#39;,)) threading.Thread(self.stream, **(\u0026#39;target\u0026#39;,)).start() return None def stream(self): self.cap = cv2.VideoCapture(0) if not self.cap.isOpened(): messagebox.showerror(\u0026#39;Error\u0026#39;, \u0026#39;‚ùå Cannot open video stream.\u0026#39;) self.reset_buttons() return None if None.streaming: (ret, frame) = self.cap.read() if not ret: pass else: frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB) img = Image.fromarray(frame_rgb) imgtk = ImageTk.PhotoImage(img, **(\u0026#39;image\u0026#39;,)) self.video_label.imgtk = imgtk self.video_label.config(imgtk, **(\u0026#39;image\u0026#39;,)) if not self.streaming: self.cap.release() self.reset_buttons() return None def stop_streaming(self): self.streaming = False if self.cap: self.cap.release() self.window.after(100, self.window.destroy) def reset_buttons(self): self.start_btn.config(tk.NORMAL, **(\u0026#39;state\u0026#39;,)) self.stop_btn.config(tk.DISABLED, **(\u0026#39;state\u0026#39;,)) def on_close(self): self.streaming = False if self.cap: self.cap.release() self.window.destroy() root = tk.Tk() app = App(root) root.protocol(\u0026#39;WM_DELETE_WINDOW\u0026#39;, app.on_close) root.mainloop() this looks like an application that uses your webcam to display a real-time video feed with OpenCV.\nüì¶ lessons to note pyInstaller doesn\u0026rsquo;t truly compile it\u0026rsquo;s packages. security through obscurity isn‚Äôt real security. tools like pyinstxtractor, pycdc are powerful allies for binary introspection. always check the Python version before decompiling. üìå final thoughts reverse engineering can be easy with the help of AI tools like chatgpt and likely tooling but still requires a methodical approach.\nalways make sure you‚Äôre authorized to reverse engineer the application you‚Äôre looking into. This stuff gets legally gray real fast.\n","permalink":"http://localhost:1313/posts/reverse-engineer-python-gui-application/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eDisclaimer: this blog post is meant strictly for educational and ethical security research. Do not reverse engineer software without permission.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"-introduction\"\u003eüß† introduction\u003c/h2\u003e\n\u003cp\u003ereverse engineering python applications can be fascinating, especially when they‚Äôre bundled into \u003ccode\u003e.exe\u003c/code\u003e files using tools like pyinstaller. In this post, I\u0026rsquo;ll walk you through how I deconstructed a windows executable (\u003ccode\u003eapp.exe\u003c/code\u003e), identified it as a pyinstaller package, and recovered the original \u003ccode\u003eapp.py\u003c/code\u003e source code.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-step-1-passive-recon\"\u003eüîç step 1: passive recon\u003c/h2\u003e\n\u003cp\u003eI started with no source just a single \u003ccode\u003eapp.exe\u003c/code\u003e binary.\u003c/p\u003e","title":"reverse engineering a python application built using pyinstaller"},{"content":"","permalink":"http://localhost:1313/projects/","summary":"","title":""},{"content":"I am sahl and I make, break and hack stuff.\nget my resume here\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI am \u003cstrong\u003esahl\u003c/strong\u003e and I make, break and hack stuff.\u003c/p\u003e\n\u003cp\u003eget my resume \u003ca href=\"/files/resume.pdf\"\u003ehere\u003c/a\u003e\u003c/p\u003e","title":"welcome to my blog!"}]